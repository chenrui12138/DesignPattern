# 设计模式

> ### **思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。**

## 01如何评价代码质量的高低？

### 可维护性（maintainability）

可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水
平等诸多因素有关。

### 可读性（readability）

代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因

### 可扩展性（extensibility）

表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。

### 灵活性（flexibility）

如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。

### 简洁性（simplicity）

那就是 KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味 着易读、易维护。

### 可复用性（reusability）

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。 可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果 。

### 可测试性（testability）

代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。

## 02 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

### 面对对象

主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。
面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

- 面向对象的四大特性：封装、抽象、继承、多态
- 面向对象编程与面向过程编程的区别和联系
- 面向对象分析、面向对象设计、面向对象编程
- 接口和抽象类的区别以及各自的应用场景
- 基于接口而非实现编程的设计思想
- 多用组合少用继承的设计思想
- 面向过程的贫血模型和面向对象的充血模型

#### OOP(面向对象)七大原则

##### 单一职责原则

**控制类的粒度大小，将对象解耦，提高内聚性。**一个对象应该只包含单一的职责，并且该职责被完整地封装到一个类里

##### 开闭原则

**对扩展开放，对修改关闭**。即实现在不修改源代码的情况下改变这个模块的行为。

**核心：对系统进行抽象化，并从抽象化导出具体化**

##### 里氏替换原则

**继承必须确保超类所拥有的性质在子类中仍然成了成立。**任何基类可以出现的地方，子类一定可以出现。

子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）、要比父类方法的输入参数更宽松。
当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

##### 依赖倒置原则

**面向接口编程，不要面向实现编程**

##### 接口隔离原则

**要为各个类建立它们需要的接口，**使用多个专门的接口来取代一个统一的接口。

##### 合成复用原则

**尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。**

##### 迪米特法则

**只与你的直接朋友交谈，不跟“陌生人”说话。**即一个软件实体对其他实体的引用越少越好，或者说如果两个类就不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。

### 设计原则

设计原则是指导我们代码设计的一些经验总结。 几个常用的设计原则：

- SOLID 原则 -SRP 单一职责原则
- SOLID 原则 -OCP 开闭原则
- SOLID 原则 -LSP 里式替换原则
- SOLID 原则 -ISP 接口隔离原则

- SOLID 原则 -DIP 依赖倒置原则
- DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

### 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。 经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如
Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。

GOF23,23种设计模式。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性以及类的关联关系和组合关系的充分理解。

优点：

- 可以提高程序员的思维能力，编程能力和设计能力。
- 使程序设计更加标准化，代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强。

==创建型模式：==

 常用：    **单例模式，工厂模式，抽象工厂模式，建造者模式**

 不常用： **原型模式。**

==结构型模式：==

 常用：**适配器模式，桥接模式，装饰模式，代理模式。**

 不常用：**组合模式，外观模式（门面模式），享元模式**

==行为型模式：==

 常用：**模板方法模式，迭代器模式，观察者模式，状态模式，策略模式，职责模式。**

 不常用：**备忘录模式，命令模式，中介模式，解释器模式，访问者模式。**

### 编程规范

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节 。

### 代码重构

持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步 ，而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。

- 重构的目的（why）、对象（what）、时机（when）、方法（how）；

- 保证重构不出错的技术手段：单元测试和代码的可测试性；
- 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

### 五者之间的联系

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。
设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。
设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。
编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。
重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

![image-20220824221632153](设计模式.assets/image-20220824221632153.png)

***

## 面对对象

**面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。**

一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。 反过来讲，即便我们使用面向对象编程语言， 写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

**按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。**

is a代表的是类之间的继承关系，比如PC机是计算机，工作站也是计算机。PC机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用Java语言实现时，应该将PC机和工作站定义成两种类，均继承计算机类。

has
a代表的是对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一台PC机的操作系统是Windows，另一台PC机的操作系统是Linux。操作系统是PC机的一个成员变量，根据这一成员变量的不同值，可以区分不同的PC机对象。

**is a的意思是如果A是B，那么B就是A的基类。**

**has a 是如果A中有B，那么，B就是A的组成部分**

### 面向对象分析

面向对象分析（OOA），全称是 Object Oriented Analysis

### 面向对象设计

面向对象设计（OOD） ，全称是 Object Oriented Design。

### 面向对象编程

面向对象编程（OOP） 全称是 Object Oriented Programming。

**面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、继承、多态三个特性，作为代码设计和实现的基石 。**

OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。
围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。

### 统一建模语言（UML）

UML（UnifiedModel Language），统一建模语言。 常用它来画图表达面向对象或设计模式的设计思路。 包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等

***

### 面向对象的特性

#### 封装（**Encapsulation**）

> 封装也叫做信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类的类提供的 方式（或者叫函数）来访问内部信息或数据。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是**访问权限控制。**如果没有提供访问权限控制语法，则没有办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性。

#### 抽象（Abstraction）

> 抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

实际上，抽象的实现，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类抽象出接口类，才叫作抽象。即便不编写接口类，单纯的实现类本身就满足抽象特性。

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。

#### 继承（Inheritance）

> 继承是用来表示类之间的is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用paraentheses()，Ruby 使用 <
。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl 等。

**继承最大的一个好处就是代码复用。**

#### 多态（Polymorphism）

> 多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

```java
public class DynamicArray { 
    private static final int DEFAULT_CAPACITY = 10; 
    protected int size = 0; 
    protected int capacity = DEFAULT_CAPACITY; 
    protected Integer[] elements = new Integer[DEFAULT_CAPACITY]; 
    
    public int size() { return this.size; } 
    public Integer get(int index) { return elements[index];} 
    //... 省略 n 多方法... 
    public void add(Integer e) { 
        ensureCapacity(); 
        elements[size++] = e; 
    } 
    
    protected void ensureCapacity() { 
        //... 如果数组满了就扩容... 代码省略... 
    } 
} 

public class SortedDynamicArray extends DynamicArray { 
    @Override 
    public void add(Integer e) { 
        ensureCapacity(); 
        for (int i = size-1; i>=0; --i) { // 保证数组中的数据有序
            if (elements[i] > e) { 
                elements[i+1] = elements[i]; 
            } else { 
                break; 3
            } 
        } 
        elements[i+1] = e; 
        ++size; 
    } 
} 
public class Example { 
    public static void test(DynamicArray dynamicArray) { 
        dynamicArray.add(5); 
        dynamicArray.add(1); 
        dynamicArray.add(3); 
        for (int i = 0; i < dynamicArray.size(); ++i) {
            System.out.println(dynamicArray[i]); 
        } 
    } 
    public static void main(String args[]) { 
        DynamicArray dynamicArray = new SortedDynamicArray(); 
        test(dynamicArray); // 打印结果：1、3、5 
    }     
}
```

**多态这种特性也需要编程语言提供特殊的语法机制来实现。**在上面的例子中，我们用到了三个语法机制来实现多态。

- 第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将SortedDynamicArray 传递给 DynamicArray。
- 第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。
- 第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add()方法，也就是实现了多态特性。

对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing
这两种语法机制，比如 C++就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

##### 利用接口类来实现多态特性

```java
public interface Iterator { 
    String hasNext(); 
    String next(); 
    String remove();
} 
public class Array implements Iterator { 
    private String[] data; 
    public String hasNext() { ... } 
    public String next() { ... } 
    public String remove() { ... } 
    //... 省略其他方法... 
} 
public class LinkedList implements Iterator { 
    private LinkedListNode head; 
    public String hasNext() { ... } 
    public String next() { ... } 
    public String remove() { ... } 
    //... 省略其他方法... 
} 
public class Demo { 
    private static void print(Iterator iterator) { 
        while (iterator.hasNext()) { 
            System.out.println(iterator.next()); 
        } 
    } 
    public static void main(String[] args) {
        Iterator arrayIterator = new Array(); 
        print(arrayIterator); 
        Iterator linkedListIterator = new LinkedList(); 
        print(linkedListIterator); 
    } 
}
```

Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator
iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。

**像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。**

***

### 面向对象编程和面向过程编程的区别

#### 面向过程

面向过程编程也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程

#### 面向对象编程相比起面向过程编程的优势主要有三个。

- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。

- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。

- 从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。

### 抽象类和接口

#### 抽象类和接口的语法特性

抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

#### 抽象类和接口存在的意义

抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

#### 抽象类和接口的应用场景区别

如果要表示一种is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。

### 接口

> **“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。**

从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。

应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。

**
越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。**

### 继承

#### 为什么不推荐使用继承？

继承是面向对象的特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

#### 组合相比继承有哪些优势？

继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

#### 如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

***

## 开发模式（基于贫血模型的传统的开发模式，基于充血模型的 DDD 开发模式）

### 什么是贫血模型？什么是充血模型？

将数据与操作分离，BO只包含数据不含业务逻辑，业务逻辑集中在 UserService 中，数据和业务逻辑被分割到不同的类中的，就叫**贫血模型**。

**充血模型**（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中

**领域驱动设计**，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。

***

## 设计原则

SOLID、KISS、YAGNI、DRY、LOD

- SOLID 原则 -SRP 单一职责原则
- SOLID 原则 -OCP 开闭原则
- SOLID 原则 -LSP 里式替换原则
- SOLID 原则 -ISP 接口隔离原则

- SOLID 原则 -DIP 依赖倒置原则
- DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

### 单一职责原则（SRP）

单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。英文描述：A class or module should have a single
reponsibility，也就是：一个类或者模块只负责完成一个职责（或者功能）。

一个是类（class），一个是模块（module）。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

**单一职责原则也就是一个类只负责完成一个职责或者功能，尽量不要设计大而全的类，要设计粒度小、功能单一的类。**

实际设计过程中我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构

是否拆分的设计参考方向：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；

- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；

- 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；

- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰，需要拆分；
- 类中大量的方法都是集中操作类中的某几个属性，就需要考虑拆分；

> **并不是所有的类都是拆分的越细越好，单一职责的原则主要是减少代码的耦合性，减少类与类之间的依赖，但是拆分过细，实际上可能会适得其反，使得代码可维护性变低。从而背离了单一职责原则中高内聚，低耦合的目的。**

### 开闭原则（OCP）

> 开闭原则的英文全称是 Open Closed Principle，简写为 OCP。英文描述：software entities (modules, classes, functions, etc.) should be open for extension ,but closed for modification。翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。也就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。

> **为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。**

### 里式替换（LSP）

Liskov Substitution Principle，缩写为 LSP 描述：

> Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
>
> 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏

核心：**design by contract，按照协议来设计**
父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

与多态的区别：多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

### 接口隔离原则

> 接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP。RobertMartin 在 SOLID 原则中是这样定义它的：“Clients should not be forced to dependupon interfaces that they do not use。”直译成中文的话就是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的 API接口，还可以特指面向对象编程语言中的接口,在这里我们可以理解为：一组 API 接口集合，单个 API 接口或函数，OOP 中的接口概念。

接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

把接口理解为单个接口或函数：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

以把“接口”理解为 OOP 中的接口：也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

#### 与单一职责原则的区别

单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。



### 依赖反转原则(依赖倒置原则)

依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。

> High-level modules shouldn’t depend on low-level modules. Both modulesshould depend on abstractions. In addition, abstractions shouldn’t depend ondetails. Details depend on abstractions.
>
> 我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）

#### 1.控制反转

实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

#### **2. 依赖注入**

依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

#### **3. 依赖注入框架**

我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

#### **4. 依赖反转原则**

依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

***

### KISS原则

> Keep It Simple and Straightforward.
>
> 尽量保持简单

不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。

不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug 的概率会更高，维护的成本也比较高。

不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

### YAGNI 原则

> You Ain’t Gonna Need It。直译就是：你不会需要它。
>
> 核心就是不要做过度设计

两者区别：

KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。

### DRY原则

> Don’t Repeat Yourself。中文直译为：不要重复自己。
>
> 核心就是：不要写重复的代码。

重复分为：实现逻辑重复、功能语义重复、代码执行重复。

实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。

提高代码可复用性的一些方法：

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉:
- 从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。
- 继承、多态、抽象、封装
- 应用模板等设计模式

在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

### 迪米特法则

> Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.
>
> 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）
>
> **不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。**
>
> 迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

**“高内聚、松耦合”能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。**

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

***

## 重构

> 软件设计大师 Martin Fowler 是这样定义重构的： **重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。**
>
> 也可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。

#### 重构的目的

- 重构是时刻保证代码质量的一个极其有效的手段
- 优秀的代码或架构不是一开始就能完全设计好的，我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。
- 重构是避免过度设计的有效手段
- **重构对一个工程师本身技术的成长也有重要的意义**，重构能力也是衡量一个工程师代码能力的有效手段

#### 重构的对象

**重构的规模，我们可以笼统地分为大规模高层次重构和小规模低层次的重构。**

大规模高层次重构：指的是对顶层代码设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。利用的更多的是比较抽象、比较顶层的设计思想、原则、模式

小规模低层次的重构：指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。更多的是利用编码规范这一理论知识

#### 重构的时机

**持续重构把持续重构也作为开发的一部分，成为一种开发习惯**。尽管说重构能力很重要，但持续重构意识更重要。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。而不是等到代码出现很大问题的时候，再大刀阔斧地重构。

#### 重构的方法

大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助一些静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。

## 单元测试

单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。

单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。

### 单元测试的目的

单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。单元测试能有效地发现代码中的bug， 写单元测试能发现代码设计上的问题，单元测试是对集成测试的有力补充。

### 如何写单元测试

写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。可以利用一些测试框架来简化单元测试的编写。除此之外，对于单元测试，

需要建立以下正确的认知：

- 编写单元测试尽管繁琐，但并不是太耗时；
- 我们可以稍微放低对单元测试代码质量的要求；
- 覆盖率作为衡量单元测试质量的唯一标准是不合理的；
- 单元测试不要依赖被测代码的具体实现逻辑；
- 单元测试框架无法测试，多半是因为代码的可测试性不好。

## 设计原则和规范重构总结：

![33630600418446744071570899244](设计模式.assets/33630600418446744071570899244.png)

=======
![image-187466291118446744071939376249](设计模式.assets/187466291118446744071939376249.png)


![image-33630600418446744071570899244](设计模式.assets/33630600418446744071570899244.png)





## 创建型模式

### 单例模式

一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

#### 单例的用处

从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。

#### 单例的实现

##### 饿汉式

饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。

##### 懒汉式

懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。

##### 双重检测

双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。

##### 静态内部类

利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。

##### 枚举

最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。

#### 单例存在的问题

- 单例对 OOP 特性的支持不友好

- 单例会隐藏类之间的依赖关系

- 单例对代码的扩展性不友好

- 单例对代码的可测试性不友好

- 单例不支持有参数的构造函数

#### **如何理解单例模式的唯一性？**

单例类中对象的唯一性的作用范围是“进程唯一”的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。

####  **如何实现线程唯一的单例？**

我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 并发工具类，可以更加轻松地实现线程唯一单例。

#### **如何实现集群环境下的单例？**

我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。

####  **如何实现一个多例模式？**

“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个© 版权归极客邦科技所有，未经许可不得传播售卖。 页面已增加防盗追踪，如有侵权极客邦将依法追究其法律责任。Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。



### 工厂模式

分类：简单工厂模式（静态工厂模式），工厂方法模式，抽象方法模式。

这种设计模式也是 Java 开发中最常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多`ifelse`的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使用中，逐步降低。
