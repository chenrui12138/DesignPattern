# 设计模式

> ### **思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。**



## 如何评价代码质量的高低？

### 可维护性（maintainability）

可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水
平等诸多因素有关。  

### 可读性（readability）  

代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因  

### 可扩展性（extensibility）  

表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。   

### 灵活性（flexibility）  

如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。  

### 简洁性（simplicity）  

那就是 KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味
着易读、易维护。

### 可复用性（reusability）    

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。  可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果 。

### 可测试性（testability）  

代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。  















GOF23,23种设计模式。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态性以及类的关联关系和组合关系的充分理解。

优点：

- 可以提高程序员的思维能力，编程能力和设计能力。
- 使程序设计更加标准化，代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强。

==创建型模式：==

​		**单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式。**

==结构型模式：==

​		**适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。**

==行为型模式：==

​		**模板方法模式，命令模式，迭代器模式，观察者模式，中介模式，备忘录模式，解释器模式，状态模式，策略模式，职责模式，访问者模式。**

## OOP(面向对象)七大原则

### 单一职责原则

**控制类的粒度大小，将对象解耦，提高内聚性。**一个对象应该只包含单一的职责，并且该职责被完整地封装到一个类里

### 开闭原则

**对扩展开放，对修改关闭**。即实现在不修改源代码的情况下改变这个模块的行为。

**核心：对系统进行抽象化，并从抽象化导出具体化**

### 里氏替换原则

**继承必须确保超类所拥有的性质在子类中仍然成了成立。**任何基类可以出现的地方，子类一定可以出现。

子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
子类中可以增加自己特有的方法。
当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）、要比父类方法的输入参数更宽松。
当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

### 依赖倒置原则

**面向接口编程，不要面向实现编程**

### 接口隔离原则

**要为各个类建立它们需要的接口，**使用多个专门的接口来取代一个统一的接口。

### 合成复用原则

**尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。**

### 迪米特法则

**只与你的直接朋友交谈，不跟“陌生人”说话。**即一个软件实体对其他实体的引用越少越好，或者说如果两个类就不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。

## 创建型模式

### 工厂模式

分类：简单工厂模式（静态工厂模式），工厂方法模式，抽象方法模式。 

这种设计模式也是 Java 开发中最常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多`ifelse`的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使用中，逐步降低。